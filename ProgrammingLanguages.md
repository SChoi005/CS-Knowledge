# Programming Languages

## The Genealogy Of Programming Languages
![image](https://user-images.githubusercontent.com/64727012/168456695-3439ce55-a9e6-4a29-8241-1768aafe45d0.png)

## Programming Languages According To Usage
* Enterprise Programming
  * Java, Web(HTML,CSS), JavaScript, PHP, Ruby, SQL 
* Data Analysis
  * Python, R
* Embedded System Programming
  * C, C++ 
* Mobile Programmng
  * Java, Kotlin, Objective-C, Swift 
* Other Programming languages
  * Scratch - For Kids
  * Go - Google in Background
  * Scala - Improved Java, used in Spark (Big Data Platform)
  * F# - ML family on .NET (Functional PL)
  * Haskell - Modern Lisp with Concurrency
  * Groovy - Make Java as Python
  * TypeScript - Improved JavaScript, MS in Background

## Programming Paradigm
* Imperative Programming - Control Flow
  * C, BASIC 
* Functional Programming
  * Lisp, Haskell, F#
* Object-Oriented programming
  * C++, Java 
* Logic Programming
  * Prolog 
* Etc - Data Flow Programming, Event Driven Programming, Reactive Programming, Concurrent Programming

## PROs and CONs of PLs
![image](https://user-images.githubusercontent.com/64727012/168457045-2e993065-15e5-42d8-8c8e-4eaf9874ce75.png)

## Java Functional Programming
* Java8 - Functional Programming feature is added.
  * Lambda Expression
  ```java
    (int a, int b) -> a*b
  ```
  * Stream
  ```java
    long count = menu.stream()
		                  .filter(d -> d.getCalories() > 300)
		                  .distinct().limit(3).count();
  ```
## Groovy - Give Python Power to Java

### Groovy vs Java
* All Java program can run as Groovy
* Groovy can run in interpreter mode
* Groovy program is not necessary to be a Class
* Groovy program can run without main method
* Groovy is dynamic typing Language
* Groovy does not need a variable type definition â€“ has type inference system

## Type Classification
![image](https://user-images.githubusercontent.com/64727012/168457368-7b6b91b3-f5d2-4e94-a986-35ba78e45bc2.png)
* Dynamic/Static typing
  * Dynamic typing does not need to write type because it has type inference system, but Static typing does not. 
* Strong/Weak typing
  * Strong typing is to inspect whether two data types are compatible, if they do not, to occur error or convert data type compulsorily. Conversely, Weak typing is not to inspect data type and not to be responsible for behaviors of programmers.  

## Interpreters and Compilers
![image](https://user-images.githubusercontent.com/64727012/168457685-b14da7da-b9b7-4b23-8e9a-e73a003c3177.png)

<strong>Reference</strong>
* Robert W. Sebestra, "Concepts Of Programming Languages, 10th Edition"

